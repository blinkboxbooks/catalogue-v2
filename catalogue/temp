
  override def getBooksById(ids: Iterable[String], idParam: String, page: Page) = Future {
    val list = bookService.getBooksDTO(ids.toList) match {
      case dto if dto != null => dto.toList
      case _ => List.empty
    }
    getBookListPage(list, page, params = Some(ids.toSeq.map(v => (idParam, v))))
  }

  override def getBooksByContributor(contributorId: String, contributorParam: String, minPubDate: Option[DateTime],
                                     minPubDateParam: String, maxPubDate: Option[DateTime], maxPubDateParam: String,
                                     fmt: DateTimeFormatter, page: Page, order: SortOrder) = Future {
    val ids = contributorService.findBookIsbnsByContributorId(contributorId, site, locale, format, sortOrder(order.field),
        order.desc, jDate(minPubDate), jDate(maxPubDate)).toList
    val params = Some(Seq((contributorParam, contributorId)))
    getBookListPageFromIsbns(ids, params, minPubDate, minPubDateParam, maxPubDate, maxPubDateParam, fmt, page, order)
  }

  override def getBooksByCategory(categoryId: Long, categoryParam: String, minPubDate: Option[DateTime],
                                  minPubDateParam: String, maxPubDate: Option[DateTime], maxPubDateParam: String,
                                  fmt: DateTimeFormatter, page: Page, order: SortOrder) = Future {
    val pair = genreService.getGenresForCategory(categoryId) match {
      case genreList if genreList != null && genreList.nonEmpty => genreService.findBookIsbnsInMultiGenre(locale, format,
        genreList, sortOrder(order.field), site, order.desc, jDate(minPubDate), jDate(maxPubDate), page.offset, page.count)
      case _ => genreService.findBookIsbnsInCategory(categoryId, site, locale, format,
        sortOrder(order.field, seqFilter = true), order.desc, jDate(minPubDate), jDate(maxPubDate), page.offset, page.count)
    }
    val params = Some(Seq((categoryParam, categoryId.toString)))
    getPagedBookListFromIsbns(pair.x, pair.y, params, minPubDate, minPubDateParam, maxPubDate, maxPubDateParam, fmt, page, order)
  }

  override def getBooksByPublisher(publisherId: Long, publisherParam: String, minPubDate: Option[DateTime],
                                   minPubDateParam: String, maxPubDate: Option[DateTime], maxPubDateParam: String,
                                   fmt: DateTimeFormatter, page: Page, order: SortOrder) = Future {
    val ids = publisherService.findBookIsbnsByPublisherId(publisherId, site, locale, format, sortOrder(order.field),
      order.desc, jDate(minPubDate), jDate(maxPubDate))
    val params = Some(Seq((publisherParam, publisherId.toString)))
    getBookListPageFromIsbns(ids, params, minPubDate, minPubDateParam, maxPubDate, maxPubDateParam, fmt, page, order)
  }

  override def getBooksByPromotion(promotionId: Long, promotionParam: String, minPubDate: Option[DateTime],
                                   minPubDateParam: String, maxPubDate: Option[DateTime], maxPubDateParam: String,
                                   fmt: DateTimeFormatter, page: Page, order: SortOrder) = Future {
    val pair: Tuple[util.List[String], Integer] = promotionService.getPromotionById(site, locale.getCountry, promotionId) match {
      case promotion if promotion != null =>
        promotion.getCategory match {
          case category if category != null => genreService.findBookIsbnsInCategory(category.getId, site, locale, format,
            sortOrder(order.field, seqFilter = true), order.desc, jDate(minPubDate), jDate(maxPubDate), page.offset, page.count)
          case _ => new Tuple(Collections.emptyList[String], 0)
        }
      case _ => new Tuple(Collections.emptyList[String], 0)
    }
    val params = Some(Seq((promotionParam, promotionId.toString)))
    getPagedBookListFromIsbns(pair.x, pair.y, params, minPubDate, minPubDateParam, maxPubDate, maxPubDateParam, fmt, page, order)
  }

  override def getBooksByCategoryLocation(locationId: Int, locationParam: String, minPubDate: Option[DateTime],
                                          minPubDateParam: String, maxPubDate: Option[DateTime], maxPubDateParam: String,
                                          fmt: DateTimeFormatter, page: Page, order: SortOrder) = Future {
    val ids = categoryService.findIsbnsByCategoryLocationId(locationId, sortOrder(order.field), order.desc,
      jDate(minPubDate), jDate(maxPubDate))
    val params = Some(Seq((locationParam, locationId.toString)))
    getBookListPageFromIsbns(ids, params, minPubDate, minPubDateParam, maxPubDate, maxPubDateParam, fmt, page, order)
  }

  private def getBookListPageFromIsbns(list: java.util.List[String], params: Option[Seq[(String, String)]],
                                       minPubDate: Option[DateTime], minPubDateParam: String, maxPubDate: Option[DateTime],
                                       maxPubDateParam: String, fmt: DateTimeFormatter, page: Page, order: SortOrder) = {
    var p = params.getOrElse(Seq.empty) ++ order.asQueryParams
    minPubDate.foreach(d => p :+= (minPubDateParam, fmt.print(d)))
    maxPubDate.foreach(d => p :+= (maxPubDateParam, fmt.print(d)))
    val dtos = getBookDto(list: _*).getOrElse(List.empty)
    getBookListPage(dtos, page, params = Some(p))
  }

  private def getBookListPage(list: java.util.List[BookDTO], page: Page, path: String = "", params: Option[Seq[(String, String)]] = None) = {
    val links = if (list.size > page.count) {
      val paging = Paging.links(Some(list.size), page.offset, page.count, s"$serviceBaseUrl$path", params, includeSelf = false)
      Some(paging.toList.map(pageLink2Link))
    } else None
    val listSlice = list.slice(page.offset, page.offset + page.count)
    ListPage(list.size, page.offset, listSlice.size, bookList(listSlice, getMediaMap(listSlice.map(_.getIsbn): _*), linkHelper), links)
  }

  /** Special case for books retrieval by category & promotion **/
  private def getPagedBookListFromIsbns(list: java.util.List[String], numberOfResults: Int, params: Option[Seq[(String, String)]],
                                        minPubDate: Option[DateTime], minPubDateParam: String, maxPubDate: Option[DateTime],
                                        maxPubDateParam: String, fmt: DateTimeFormatter, page: Page, order: SortOrder) = {
    var p = params.getOrElse(Seq.empty) ++ order.asQueryParams
    minPubDate.foreach(d => p :+= (minPubDateParam, fmt.print(d)))
    maxPubDate.foreach(d => p :+= (maxPubDateParam, fmt.print(d)))
    val dtos = getBookDto(list: _*).getOrElse(List.empty)
    getPagedBookList(dtos, numberOfResults, page, params = Some(p))
  }

  /** Special case for books retrieval by category & promotion **/
  private def getPagedBookList(list: java.util.List[BookDTO], numberOfResults: Int, page: Page, path: String = "", params: Option[Seq[(String, String)]] = None) = {
    val links = if (numberOfResults > page.count) {
      val paging = Paging.links(Some(numberOfResults), page.offset, page.count, s"$serviceBaseUrl$path", params, includeSelf = false)
      Some(paging.toList.map(pageLink2Link))
    } else None
    ListPage(numberOfResults, page.offset, list.size, bookList(list, getMediaMap(list.map(_.getIsbn): _*), linkHelper), links)
  }

  private def getBookDto(isbn: String*): Option[List[BookDTO]] = {
    if (isbn.nonEmpty) {
      bookService.getBooksDTO(isbn) match {
        case dtos if dtos != null && dtos.nonEmpty => Some(dtos.toList)
        case _ => None
      }
    } else None
  }

  private def getMediaMap(isbn: String*): Option[Map[String, Map[BookMediaType, BookMediaDTO]]] = {
    if (isbn.nonEmpty) Option(bookMediaService.getMediaForIsbns(isbn).toMap.mapValues(_.toMap)) else None
  }
}

*/
